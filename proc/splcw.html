<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
   <meta name="description" content="Fitting (least squares) a multidimensional cubic spline to arbitrarily located data">
    <meta name="author" content="Jacob Williams" >
    <link rel="icon" href="../favicon.png">

    <title>splcw &ndash; splpak</title>

    <link href="../css/bootstrap.min.css" rel="stylesheet">
    <link href="../css/pygments.css" rel="stylesheet">
    <link href="../css/font-awesome.min.css" rel="stylesheet">
    <link href="../css/local.css" rel="stylesheet">
    <link  href="../tipuesearch/tipuesearch.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
    
    <script src="../js/jquery-2.1.3.min.js"></script>
    <script src="../js/svg-pan-zoom.min.js"></script>

  </head>

  <body>

    <!-- Fixed navbar -->
    <nav class="navbar navbar-inverse navbar-fixed-top">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="../index.html">splpak </a>
        </div>
        <div id="navbar" class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <li class="dropdown hidden-xs visible-sm visible-md hidden-lg">
              <a href="#" class="dropdown-toggle"
              data-toggle="dropdown" role="button"
              aria-haspopup="true"
     aria-expanded="false">Contents <span class="caret"></span></a>
        <ul class="dropdown-menu">
            <li><a href="../sourcefile/splpak.f90.html">Source File</a></li>
            <li><a href="../lists/modules.html">Modules</a></li>
            <li><a href="../lists/procedures.html">Procedures</a></li>
                   <li><a href="../lists/types.html">Derived Types</a></li>
       
            </ul>
        
            </li>
<li class="visible-xs hidden-sm visible-lg"><a href="../sourcefile/splpak.f90.html">Source File</a></li>
<li class="visible-xs hidden-sm visible-lg"><a href="../lists/modules.html">Modules</a></li>
<li class="visible-xs hidden-sm visible-lg"><a href="../lists/procedures.html">Procedures</a></li>
                             <li class="visible-xs hidden-sm visible-lg"><a href="../lists/types.html">Derived Types</a></li>
          </ul>
        <form action="../search.html" class="navbar-form navbar-right" role="search">
        <div class="form-group">
          <input type="text" class="form-control" placeholder="Search" name="q" id="tipue_search_input" autocomplete="off" required>
        </div>
<!--
        <button type="submit" class="btn btn-default">Submit</button>
-->
        </form>
        </div><!--/.nav-collapse -->
      </div>
    </nav>

    <div class="container">
  <div class="row">
    <h1>splcw
      <small>Subroutine</small>
      
    </h1>
      <div class="row" id="info-bar">
    <div class="col-lg-12">
      <div class="well well-sm">
        <ul class="list-inline" style="margin-bottom:0px;display:inline">

          <li id="statements"><i class="fa fa-list-ol"></i>
            <a data-toggle="tooltip"
               data-placement="bottom" data-html="true"
               title="30.6% of total for procedures.">213 statements</a>
          </li>

            <li id="source-file">
              <i class="fa fa-code"></i>
              <a href="../src/splpak.F90"> Source File</a>
            </li>
        </ul>
        <ol class="breadcrumb in-well text-right">
              <li><a href='../sourcefile/splpak.f90.html'>splpak.F90</a></li>
              <li><a href='../module/splpak_module.html'>splpak_module</a></li>
          <li class="active">splcw</li>
        </ol>
      </div>
    </div>
  </div>
  <script>
    $(function () {
    $('[data-toggle="tooltip"]').tooltip()
    })
  </script>

  </div>
  
  <div class="row">
    <div class="col-md-3 hidden-xs hidden-sm visible-md visible-lg">
      <div id="sidebar">
      <h3>Contents</h3>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
    <div class="panel panel-primary">
      <div class="panel-heading text-left"><h3 class="panel-title">Source Code</h3></div>
      <div class="list-group">
        <a class="list-group-item" href="../proc/splcw.html#src">splcw</a>
      </div>
    </div>


  </div>

    </div>
    
    <div class="col-md-9" id='text'>
    <h2>private  subroutine splcw(me, ndim, xdata, l1xdat, ydata, wdata, ndata, xmin, xmax, nodes, xtrap, coef, ncf, work, nwrk, ierror)  
</h2>
    

    <p>N-dimensional cubic spline coefficient
  calculation by weighted least squares on
  arbitrarily located data.</p>
<p>The spline (or its derivatives) may then be
  evaluated by using function <a href="../proc/splfe.html">splfe</a> (or <a href="../proc/splde.html">splde</a>).</p>
<p>A grid of evenly spaced nodes in NDIM space is
  defined by the arguments XMIN, XMAX and NODES.
  A linear basis for the class of natural splines
  on these nodes is formed, and a set of
  corresponding coefficients is computed in the
  array COEF.  These coefficients are chosen to
  minimize the weighted sum of squared errors
  between the spline and the arbitrarily located
  data values described by the arguments XDATA,
  YDATA and NDATA.  The smoothness of the spline
  in data sparse areas is controlled by the
  argument XTRAP.</p>
<h3>Note</h3>
<p>In order to understand the arguments of this
  routine, one should realize that the node grid
  need not bear any particular relation to the
  data points.  In the theory of exact-fit
  interpolatory splines, the nodes would in fact
  be data locations, but in this case they serve
  only to define the class of splines from which
  the approximating function is chosen.  This
  node grid is a rectangular arrangement of
  points in NDIM space, with the restriction that
  along any coordinate direction the nodes are
  equally spaced.  The class of natural splines
  on this grid of nodes (NDIM-cubic splines whose
  2nd derivatives normal to the boundaries are 0)
  has as many degrees of freedom as the grid has
  nodes.  Thus the smoothness or flexibility of
  the splines is determined by the choice of the
  node grid.</p>
<h3>Algorithm</h3>
<p>An overdetermined system of linear equations
  is formed -- one equation for each data point
  plus equations for derivative constraints.
  This system is solved using subroutine <a href="../proc/suprls.html">suprls</a>.</p>
<h3>Accuracy</h3>
<p>If there is exactly one data point in the
  near vicinity of each node and no extra data,
  the resulting spline will agree with the
  data values to machine accuracy.  However, if
  the problem is overdetermined or the sparse
  data option is utilized, the accuracy is hard
  to predict.  Basically, smooth functions
  require fewer nodes than rough ones for the
  same accuracy.</p>
<h3>Timing</h3>
<p>The execution time is roughly proportional
  to <code>NDATA*NCOF**2</code> where <code>NCOF = NODES(1)*...*NODES(NDIM)</code>.</p>

    <h3>Arguments</h3>
        <table class="table table-striped varlist">
    <thead>
      <tr>
        <th>Type</th>
<th>Intent</th><th>Optional</th>        <th>Attributes</th>
        <th></th>
        <th>Name</th>
        <th></th>
    </thead>
    <tbody>
        <tr>
            <td>
              <span class="anchor" id="variable-me~2"></span>
              class(<a href='../type/splpak_type.html'>splpak_type</a>),
            </td>
<td>intent(inout)</td>
              <td></td>            <td>
              
            </td>
            <td>::</td>
            <td><strong>me</strong></td>
            <td>
                
            </td>
        </tr>
        <tr>
            <td>
              <span class="anchor" id="variable-ndim~2"></span>
              integer,
            </td>
<td>intent(in)</td>
              <td></td>            <td>
              
            </td>
            <td>::</td>
            <td><strong>ndim</strong></td>
            <td>
                <p>The dimensionality of the problem.  The
spline is a function of <code>NDIM</code> variables or
coordinates and thus a point in the
independent variable space is an <code>NDIM</code> vector.
<code>NDIM</code> must be <code>&gt;= 1</code>.</p>
            </td>
        </tr>
        <tr>
            <td>
              <span class="anchor" id="variable-xdata"></span>
              real(kind=wp),
            </td>
<td>intent(in)</td>
              <td></td>            <td>
              
            </td>
            <td>::</td>
            <td><strong>xdata</strong>(l1xdat,ndata)</td>
            <td>
                <p>A collection of locations for the data
values, i.e., points from the independent
variable space.  This collection is a
2-dimensional array whose 1st dimension
indexes the <code>NDIM</code> coordinates of a given point
and whose 2nd dimension labels the data
point.  For example, the data point with
label <code>IDATA</code> is located at the point
<code>(XDATA(1,IDATA),...,XDATA(NDIM,IDATA))</code> where
the elements of this vector are the values of
the <code>NDIM</code> coordinates.  The location, number
and ordering of the data points is arbitrary.
The dimension of <code>XDATA</code> is assumed to be
<code>XDATA(L1XDAT,NDATA)</code>.</p>
            </td>
        </tr>
        <tr>
            <td>
              <span class="anchor" id="variable-l1xdat"></span>
              integer,
            </td>
<td>intent(in)</td>
              <td></td>            <td>
              
            </td>
            <td>::</td>
            <td><strong>l1xdat</strong></td>
            <td>
                <p>The length of the 1st dimension of <code>XDATA</code> in
 the calling program.  <code>L1XDAT</code> must be <code>&gt;= NDIM</code>.</p>
<h4>Note:</h4>
<p>For 1-dimensional problems <code>L1XDAT</code> is usually 1.</p>
            </td>
        </tr>
        <tr>
            <td>
              <span class="anchor" id="variable-ydata"></span>
              real(kind=wp),
            </td>
<td>intent(in)</td>
              <td></td>            <td>
              
            </td>
            <td>::</td>
            <td><strong>ydata</strong>(ndata)</td>
            <td>
                <p>A collection of data values corresponding to
the points in <code>XDATA</code>.  <code>YDATA(IDATA)</code> is the
data value associated with the point
<code>(XDATA(1,IDATA),...,XDATA(NDIM,IDATA))</code> in the
independent variable space.  The spline whose
coefficients are computed by this routine
approximates these data values in the least
squares sense.  The dimension is assumed to be
<code>YDATA(NDATA)</code>.</p>
            </td>
        </tr>
        <tr>
            <td>
              <span class="anchor" id="variable-wdata~2"></span>
              real(kind=wp),
            </td>
<td>intent(in)</td>
              <td></td>            <td>
              
            </td>
            <td>::</td>
            <td><strong>wdata</strong>(:)</td>
            <td>
                <p>A collection of weights.  <code>WDATA(IDATA)</code> is a
 weight associated with the data point
 labelled <code>IDATA</code>.  It should be non-negative,
 but may be of any magnitude.  The weights
 have the effect of forcing greater or lesser
 accuracy at a given point as follows: this
 routine chooses coefficients to minimize the
 sum over all data points of the quantity</p>
<div class="codehilite"><pre><span></span><code><span class="w">   </span><span class="p">(</span><span class="n">WDATA</span><span class="p">(</span><span class="n">IDATA</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">YDATA</span><span class="p">(</span><span class="n">IDATA</span><span class="p">)</span><span class="w"> </span><span class="c">! spline value at XDATA(IDATA)))**2.</span>
</code></pre></div>

<p>Thus, if the reliability
 of a data point is known to be low, the
 corresponding weight may be made small
 (relative to the other weights) so that the
 sum over all data points is affected less by
 discrepencies at the unreliable point.  Data
 points with zero weight are completely
 ignored.</p>
<h4>Note:</h4>
<p>If <code>WDATA(1)</code> is <code>&lt; 0</code>, the other
 elements of <code>WDATA</code> are not
 referenced, and all weights are
 assumed to be unity.</p>
<p>The dimension is assumed to be <code>WDATA(NDATA)</code>
 unless <code>WDATA(1) &lt; 0.</code>, in which case the
 dimension is assumed to be 1.</p>
            </td>
        </tr>
        <tr>
            <td>
              <span class="anchor" id="variable-ndata"></span>
              integer,
            </td>
<td>intent(in)</td>
              <td></td>            <td>
              
            </td>
            <td>::</td>
            <td><strong>ndata</strong></td>
            <td>
                <p>The number of data points mentioned in the
above arguments.</p>
            </td>
        </tr>
        <tr>
            <td>
              <span class="anchor" id="variable-xmin~2"></span>
              real(kind=wp),
            </td>
<td>intent(in)</td>
              <td></td>            <td>
              
            </td>
            <td>::</td>
            <td><strong>xmin</strong>(ndim)</td>
            <td>
                <p>A vector describing the lower extreme corner
of the node grid.  A set of evenly spaced
nodes is formed along each coordinate axis
and <code>XMIN(IDIM)</code> is the location of the first
node along the <code>IDIM</code> axis.  The dimension is
assumed to be <code>XMIN(NDIM)</code>.</p>
            </td>
        </tr>
        <tr>
            <td>
              <span class="anchor" id="variable-xmax~2"></span>
              real(kind=wp),
            </td>
<td>intent(in)</td>
              <td></td>            <td>
              
            </td>
            <td>::</td>
            <td><strong>xmax</strong>(ndim)</td>
            <td>
                <p>A vector describing the upper extreme corner
of the node grid.  A set of evenly spaced
nodes is formed along each coordinate axis
and <code>XMAX(IDIM)</code> is the location of the last
node along the <code>IDIM</code> axis.  The dimension is
assumed to be <code>XMAX(NDIM)</code>.</p>
            </td>
        </tr>
        <tr>
            <td>
              <span class="anchor" id="variable-nodes~2"></span>
              integer,
            </td>
<td>intent(in)</td>
              <td></td>            <td>
              
            </td>
            <td>::</td>
            <td><strong>nodes</strong>(ndim)</td>
            <td>
                <p>A vector of integers describing the number of
 nodes along each axis.  <code>NODES(IDIM)</code> is the
 number of nodes (counting endpoints) along
 the <code>IDIM</code> axis and determines the flexibility
 of the spline in that coordinate direction.
 <code>NODES(IDIM)</code> must be <code>&gt;= 4</code>, but may be as
 large as the arrays <code>COEF</code> and <code>WORK</code> allow.
 The dimension is assumed to be <code>NODES(NDIM)</code>.</p>
<h4>Note:</h4>
<p>The node grid is completely defined by
 the arguments <code>XMIN</code>, <code>XMAX</code> and <code>NODES</code>.
 The spacing of this grid in the <code>IDIM</code>
 coordinate direction is:</p>
<div class="codehilite"><pre><span></span><code><span class="w">   </span><span class="n">DX</span><span class="p">(</span><span class="nb">IDIM</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">XMAX</span><span class="p">(</span><span class="nb">IDIM</span><span class="p">)</span><span class="o">-</span><span class="n">XMIN</span><span class="p">(</span><span class="nb">IDIM</span><span class="p">))</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">NODES</span><span class="p">(</span><span class="nb">IDIM</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">).</span><span class="w"></span>
</code></pre></div>

<p>A node in this grid may be indexed by
 an <code>NDIM</code> vector of integers
 <code>(IN(1),...,IN(NDIM))</code> where
 <code>1 &lt;= IN(IDIM) &lt;= NODES(IDIM)</code>.
 The location of such a node may be
 represented by an <code>NDIM</code> vector
 <code>(X(1),...,X(NDIM))</code> where
 <code>X(IDIM) = XMIN(IDIM) + (IN(IDIM)-1) * DX(IDIM)</code>.</p>
            </td>
        </tr>
        <tr>
            <td>
              <span class="anchor" id="variable-xtrap"></span>
              real(kind=wp),
            </td>
<td>intent(in)</td>
              <td></td>            <td>
              
            </td>
            <td>::</td>
            <td><strong>xtrap</strong></td>
            <td>
                <p>A parameter to control extrapolation to data
 sparse areas.  The region described by <code>XMIN</code>
 and <code>XMAX</code> is divided into rectangles, the
 number of which is determined by <code>NODES</code>, and
 any rectangle containing a disproportionately
 small number of data points is considered to
 be data sparse (rectangle is used here to
 mean <code>NDIM</code>-dimensional rectangle).  If <code>XTRAP</code>
 is nonzero the least squares problem is
 augmented with derivative constraints in the
 data sparse areas to prevent the matrix from
 becoming poorly conditioned.  <code>XTRAP</code> serves as
 a weight for these constraints, and thus may
 be used to control smoothness in data sparse
 areas.  Experience indicates that unity is a
 good first guess for this parameter.</p>
<h4>Note:</h4>
<p>If <code>XTRAP</code> is zero, substantial
 portions of the routine will be
 skipped, but a singular matrix
 can result if large portions of
 the region are without data.</p>
            </td>
        </tr>
        <tr>
            <td>
              <span class="anchor" id="variable-coef~2"></span>
              real(kind=wp),
            </td>
<td>intent(out)</td>
              <td></td>            <td>
              
            </td>
            <td>::</td>
            <td><strong>coef</strong>(ncf)</td>
            <td>
                <p>The array of coefficients computed by this
routine.  Each coefficient corresponds to a
particular basis function which in turn
corresponds to a node in the node grid.  This
correspondence between the node grid and the
array <code>COEF</code> is as if <code>COEF</code> were an
<code>NDIM</code>-dimensional Fortran array with
dimensions <code>NODES(1),...,NODES(NDIM)</code>, i.e., to
store the array linearly, the leftmost
indices are incremented most frequently.
Hence the length of the <code>COEF</code> array must equal
or exceed the total number of nodes, which is
<code>NODES(1)*...*NODES(NDIM)</code>.  The computed array
<code>COEF</code> may be used with function <a href="../proc/splfe.html">splfe</a>
(or <a href="../proc/splde.html">splde</a>) to evaluate the spline (or its
derivatives) at an arbitrary point in <code>NDIM</code>
space.  The dimension is assumed to be <code>COEF(NCF)</code>.</p>
            </td>
        </tr>
        <tr>
            <td>
              <span class="anchor" id="variable-ncf"></span>
              integer,
            </td>
<td>intent(in)</td>
              <td></td>            <td>
              
            </td>
            <td>::</td>
            <td><strong>ncf</strong></td>
            <td>
                <p>The length of the array <code>COEF</code> in the calling
program.  If <code>NCF</code> is <code>&lt; NODES(1)*...*NODES(NDIM)</code>,
a fatal error is diagnosed.</p>
            </td>
        </tr>
        <tr>
            <td>
              <span class="anchor" id="variable-work"></span>
              real(kind=wp)
            </td>
<td></td>
              <td></td>            <td>
              
            </td>
            <td>::</td>
            <td><strong>work</strong>(nwrk)</td>
            <td>
                <p>A workspace array for solving the least
squares matrix generated by this routine.
Its required size is a function of the total
number of nodes in the node grid.  This
total, <code>NCOL = NODES(1)*...*NODES(NDIM)</code>, is
also the number of columns in the least
squares matrix.  The length of the array <code>WORK</code>
must equal or exceed <code>NCOL*(NCOL+1)</code>.</p>
            </td>
        </tr>
        <tr>
            <td>
              <span class="anchor" id="variable-nwrk"></span>
              integer,
            </td>
<td>intent(in)</td>
              <td></td>            <td>
              
            </td>
            <td>::</td>
            <td><strong>nwrk</strong></td>
            <td>
                <p>The length of the array <code>WORK</code> in the calling
program.  If
<code>NCOL = NODES(1)*...*NODES(NDIM)</code> is the total
number of nodes, then a fatal error is
diagnosed if <code>NWRK</code> is less than
<code>NCOL*(NCOL+1)</code>.</p>
            </td>
        </tr>
        <tr>
            <td>
              <span class="anchor" id="variable-ierror~2"></span>
              integer,
            </td>
<td>intent(out)</td>
              <td></td>            <td>
              
            </td>
            <td>::</td>
            <td><strong>ierror</strong></td>
            <td>
                <p>An error flag with the following meanings:</p>
<ul>
<li><code>0</code>  No error.</li>
<li><code>101</code>  <code>NDIM</code> is &lt; 1.</li>
<li><code>102</code>  <code>NODES(IDIM)</code> is &lt; 4 for some <code>IDIM</code>.</li>
<li><code>103</code>  <code>XMIN(IDIM) = XMAX(IDIM)</code> for some <code>IDIM</code>.</li>
<li><code>104</code>  <code>NCF</code> (size of <code>COEF</code>) is <code>&lt; NODES(1)*...*NODES(NDIM)</code>.</li>
<li><code>105</code>  <code>NDATA</code> is <code>&lt; 1</code>.</li>
<li><code>106</code>  <code>NWRK</code> (size of <code>WORK</code>) is too small.</li>
<li><code>107</code>  <a href="../proc/suprls.html">suprls</a> failure (usually insufficient
  data) -- ordinarily occurs only if
  <code>XTRAP</code> is zero or <code>WDATA</code> contains all
  zeros.</li>
</ul>
            </td>
        </tr>
    </tbody>
  </table>

    <br>
    <div class="panel panel-default">
      <div class="panel-heading">
  <h3 class="panel-title">Calls</h3>
      </div>
      <div class="panel-body">
  <div class="depgraph"><?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.43.0 (0)
 -->
<!-- Title: proc~~splcw~~CallsGraph Pages: 1 -->
<svg id="procsplcwCallsGraph" width="152pt" height="32pt"
 viewBox="0.00 0.00 152.00 32.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="proc~~splcw~~CallsGraph" class="graph" transform="scale(1 1) rotate(0) translate(4 28)">
<title>proc~~splcw~~CallsGraph</title>
<polygon fill="white" stroke="transparent" points="-4,4 -4,-28 148,-28 148,4 -4,4"/>
<!-- proc~splcw -->
<g id="proc~~splcw~~CallsGraph_node1" class="node">
<title>proc~splcw</title>
<polygon fill="none" stroke="black" points="54,-24 0,-24 0,0 54,0 54,-24"/>
<text text-anchor="middle" x="27" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50">splcw</text>
</g>
<!-- proc~cfaerr -->
<g id="proc~~splcw~~CallsGraph_node2" class="node">
<title>proc~cfaerr</title>
<g id="a_proc~~splcw~~CallsGraph_node2"><a xlink:href=".././proc/cfaerr.html" xlink:title="cfaerr">
<polygon fill="#d9534f" stroke="#d9534f" points="144,-24 90,-24 90,0 144,0 144,-24"/>
<text text-anchor="middle" x="117" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">cfaerr</text>
</a>
</g>
</g>
<!-- proc~splcw&#45;&gt;proc~cfaerr -->
<g id="proc~~splcw~~CallsGraph_edge1" class="edge">
<title>proc~splcw&#45;&gt;proc~cfaerr</title>
<path fill="none" stroke="#000000" d="M54.4,-12C62.39,-12 71.31,-12 79.82,-12"/>
<polygon fill="#000000" stroke="#000000" points="79.92,-15.5 89.92,-12 79.92,-8.5 79.92,-15.5"/>
</g>
</g>
</svg>
</div><div><a type="button" class="graph-help" data-toggle="modal" href="#graph-help-text">Help</a></div><div class="modal fade" id="graph-help-text" tabindex="-1" role="dialog"><div class="modal-dialog modal-lg" role="document"><div class="modal-content"><div class="modal-header"><button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button><h4 class="modal-title" id="-graph-help-label">Graph Key</h4></div><div class="modal-body">
    <p>Nodes of different colours represent the following: </p>
    <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.43.0 (0)
 -->
<!-- Title: Graph Key Pages: 1 -->
<svg width="597pt" height="32pt"
 viewBox="0.00 0.00 596.50 32.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 28)">
<title>Graph Key</title>
<polygon fill="white" stroke="transparent" points="-4,4 -4,-28 592.5,-28 592.5,4 -4,4"/>
<!-- Subroutine -->
<g id="node1" class="node">
<title>Subroutine</title>
<polygon fill="#d9534f" stroke="#d9534f" points="70,-24 0,-24 0,0 70,0 70,-24"/>
<text text-anchor="middle" x="35" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">Subroutine</text>
</g>
<!-- Function -->
<g id="node2" class="node">
<title>Function</title>
<polygon fill="#d94e8f" stroke="#d94e8f" points="146,-24 88,-24 88,0 146,0 146,-24"/>
<text text-anchor="middle" x="117" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">Function</text>
</g>
<!-- Interface -->
<g id="node3" class="node">
<title>Interface</title>
<polygon fill="#a7506f" stroke="#a7506f" points="225.5,-24 164.5,-24 164.5,0 225.5,0 225.5,-24"/>
<text text-anchor="middle" x="195" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">Interface</text>
</g>
<!-- Unknown Procedure Type -->
<g id="node4" class="node">
<title>Unknown Procedure Type</title>
<polygon fill="#777777" stroke="#777777" points="388.5,-24 243.5,-24 243.5,0 388.5,0 388.5,-24"/>
<text text-anchor="middle" x="316" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">Unknown Procedure Type</text>
</g>
<!-- Program -->
<g id="node5" class="node">
<title>Program</title>
<polygon fill="#f0ad4e" stroke="#f0ad4e" points="465,-24 407,-24 407,0 465,0 465,-24"/>
<text text-anchor="middle" x="436" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">Program</text>
</g>
<!-- This Page&#39;s Entity -->
<g id="node6" class="node">
<title>This Page&#39;s Entity</title>
<polygon fill="none" stroke="black" points="588.5,-24 483.5,-24 483.5,0 588.5,0 588.5,-24"/>
<text text-anchor="middle" x="536" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50">This Page&#39;s Entity</text>
</g>
</g>
</svg>

    
    <p>Solid arrows point from a procedure to one which it calls. Dashed 
    arrows point from an interface to procedures which implement that interface.
    This could include the module procedures in a generic interface or the
    implementation in a submodule of an interface in a parent module.
    </p>
    </div></div></div></div>
      </div>
    </div>
    <br>

    <section class="visible-xs visible-sm hidden-md">
        <h3>Contents</h3>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
    <div class="panel panel-primary">
      <div class="panel-heading text-left"><h3 class="panel-title">Source Code</h3></div>
      <div class="list-group">
        <a class="list-group-item" href="../proc/splcw.html#src">splcw</a>
      </div>
    </div>


    </section>
    <br class="visible-xs visible-sm hidden-md">


    
    

    
    


    
    <section>
    <h2><span class="anchor" id="src"></span>Source Code</h2>
    <div class="highlight"><pre><span></span><span class="k">subroutine </span><span class="n">splcw</span><span class="p">(</span><span class="n">me</span><span class="p">,</span><span class="n">ndim</span><span class="p">,</span><span class="n">xdata</span><span class="p">,</span><span class="n">l1xdat</span><span class="p">,</span><span class="n">ydata</span><span class="p">,</span><span class="n">wdata</span><span class="p">,</span><span class="n">ndata</span><span class="p">,</span><span class="n">xmin</span><span class="p">,</span><span class="n">xmax</span><span class="p">,</span><span class="w"> </span><span class="p">&amp;</span><span class="w"></span>
<span class="w">                 </span><span class="n">nodes</span><span class="p">,</span><span class="n">xtrap</span><span class="p">,</span><span class="n">coef</span><span class="p">,</span><span class="n">ncf</span><span class="p">,</span><span class="n">work</span><span class="p">,</span><span class="n">nwrk</span><span class="p">,</span><span class="n">ierror</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="k">class</span><span class="p">(</span><span class="n">splpak_type</span><span class="p">),</span><span class="k">intent</span><span class="p">(</span><span class="n">inout</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">me</span><span class="w"></span>
<span class="w">    </span><span class="kt">integer</span><span class="p">,</span><span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">ndim</span><span class="w"> </span><span class="c">!! The dimensionality of the problem.  The</span>
<span class="w">                               </span><span class="c">!! spline is a function of `NDIM` variables or</span>
<span class="w">                               </span><span class="c">!! coordinates and thus a point in the</span>
<span class="w">                               </span><span class="c">!! independent variable space is an `NDIM` vector.</span>
<span class="w">                               </span><span class="c">!! `NDIM` must be `&gt;= 1`.</span>
<span class="w">    </span><span class="kt">integer</span><span class="p">,</span><span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">l1xdat</span><span class="w"> </span><span class="c">!! The length of the 1st dimension of `XDATA` in</span>
<span class="w">                                 </span><span class="c">!! the calling program.  `L1XDAT` must be `&gt;= NDIM`.</span>
<span class="w">                                 </span><span class="c">!!</span>
<span class="w">                                 </span><span class="c">!!#### Note:</span>
<span class="w">                                 </span><span class="c">!! For 1-dimensional problems `L1XDAT` is usually 1.</span>
<span class="w">    </span><span class="kt">integer</span><span class="p">,</span><span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">ncf</span><span class="w"> </span><span class="c">!! The length of the array `COEF` in the calling</span>
<span class="w">                              </span><span class="c">!! program.  If `NCF` is `&lt; NODES(1)*...*NODES(NDIM)`,</span>
<span class="w">                              </span><span class="c">!! a fatal error is diagnosed.</span>
<span class="w">    </span><span class="kt">integer</span><span class="p">,</span><span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">nwrk</span><span class="w"> </span><span class="c">!! The length of the array `WORK` in the calling</span>
<span class="w">                               </span><span class="c">!! program.  If</span>
<span class="w">                               </span><span class="c">!! `NCOL = NODES(1)*...*NODES(NDIM)` is the total</span>
<span class="w">                               </span><span class="c">!! number of nodes, then a fatal error is</span>
<span class="w">                               </span><span class="c">!! diagnosed if `NWRK` is less than</span>
<span class="w">                               </span><span class="c">!! `NCOL*(NCOL+1)`.</span>
<span class="w">    </span><span class="kt">integer</span><span class="p">,</span><span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">ndata</span><span class="w"> </span><span class="c">!! The number of data points mentioned in the</span>
<span class="w">                                </span><span class="c">!! above arguments.</span>
<span class="w">    </span><span class="kt">real</span><span class="p">(</span><span class="n">wp</span><span class="p">),</span><span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">xdata</span><span class="p">(</span><span class="n">l1xdat</span><span class="p">,</span><span class="n">ndata</span><span class="p">)</span><span class="w"> </span><span class="c">!! A collection of locations for the data</span>
<span class="w">                                               </span><span class="c">!! values, i.e., points from the independent</span>
<span class="w">                                               </span><span class="c">!! variable space.  This collection is a</span>
<span class="w">                                               </span><span class="c">!! 2-dimensional array whose 1st dimension</span>
<span class="w">                                               </span><span class="c">!! indexes the `NDIM` coordinates of a given point</span>
<span class="w">                                               </span><span class="c">!! and whose 2nd dimension labels the data</span>
<span class="w">                                               </span><span class="c">!! point.  For example, the data point with</span>
<span class="w">                                               </span><span class="c">!! label `IDATA` is located at the point</span>
<span class="w">                                               </span><span class="c">!! `(XDATA(1,IDATA),...,XDATA(NDIM,IDATA))` where</span>
<span class="w">                                               </span><span class="c">!! the elements of this vector are the values of</span>
<span class="w">                                               </span><span class="c">!! the `NDIM` coordinates.  The location, number</span>
<span class="w">                                               </span><span class="c">!! and ordering of the data points is arbitrary.</span>
<span class="w">                                               </span><span class="c">!! The dimension of `XDATA` is assumed to be</span>
<span class="w">                                               </span><span class="c">!! `XDATA(L1XDAT,NDATA)`.</span>
<span class="w">    </span><span class="kt">real</span><span class="p">(</span><span class="n">wp</span><span class="p">),</span><span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">ydata</span><span class="p">(</span><span class="n">ndata</span><span class="p">)</span><span class="w"> </span><span class="c">!! A collection of data values corresponding to</span>
<span class="w">                                        </span><span class="c">!! the points in `XDATA`.  `YDATA(IDATA)` is the</span>
<span class="w">                                        </span><span class="c">!! data value associated with the point</span>
<span class="w">                                        </span><span class="c">!! `(XDATA(1,IDATA),...,XDATA(NDIM,IDATA))` in the</span>
<span class="w">                                        </span><span class="c">!! independent variable space.  The spline whose</span>
<span class="w">                                        </span><span class="c">!! coefficients are computed by this routine</span>
<span class="w">                                        </span><span class="c">!! approximates these data values in the least</span>
<span class="w">                                        </span><span class="c">!! squares sense.  The dimension is assumed to be</span>
<span class="w">                                        </span><span class="c">!! `YDATA(NDATA)`.</span>
<span class="w">    </span><span class="kt">real</span><span class="p">(</span><span class="n">wp</span><span class="p">),</span><span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">wdata</span><span class="p">(:)</span><span class="w"> </span><span class="c">!! A collection of weights.  `WDATA(IDATA)` is a</span>
<span class="w">                                    </span><span class="c">!! weight associated with the data point</span>
<span class="w">                                    </span><span class="c">!! labelled `IDATA`.  It should be non-negative,</span>
<span class="w">                                    </span><span class="c">!! but may be of any magnitude.  The weights</span>
<span class="w">                                    </span><span class="c">!! have the effect of forcing greater or lesser</span>
<span class="w">                                    </span><span class="c">!! accuracy at a given point as follows: this</span>
<span class="w">                                    </span><span class="c">!! routine chooses coefficients to minimize the</span>
<span class="w">                                    </span><span class="c">!! sum over all data points of the quantity</span>
<span class="w">                                    </span><span class="c">!!```fortran</span>
<span class="w">                                    </span><span class="c">!!   (WDATA(IDATA)*(YDATA(IDATA) ! spline value at XDATA(IDATA)))**2.</span>
<span class="w">                                    </span><span class="c">!!```</span>
<span class="w">                                    </span><span class="c">!! Thus, if the reliability</span>
<span class="w">                                    </span><span class="c">!! of a data point is known to be low, the</span>
<span class="w">                                    </span><span class="c">!! corresponding weight may be made small</span>
<span class="w">                                    </span><span class="c">!! (relative to the other weights) so that the</span>
<span class="w">                                    </span><span class="c">!! sum over all data points is affected less by</span>
<span class="w">                                    </span><span class="c">!! discrepencies at the unreliable point.  Data</span>
<span class="w">                                    </span><span class="c">!! points with zero weight are completely</span>
<span class="w">                                    </span><span class="c">!! ignored.</span>
<span class="w">                                    </span><span class="c">!!</span>
<span class="w">                                    </span><span class="c">!!#### Note:</span>
<span class="w">                                    </span><span class="c">!! If `WDATA(1)` is `&lt; 0`, the other</span>
<span class="w">                                    </span><span class="c">!! elements of `WDATA` are not</span>
<span class="w">                                    </span><span class="c">!! referenced, and all weights are</span>
<span class="w">                                    </span><span class="c">!! assumed to be unity.</span>
<span class="w">                                    </span><span class="c">!!</span>
<span class="w">                                    </span><span class="c">!! The dimension is assumed to be `WDATA(NDATA)`</span>
<span class="w">                                    </span><span class="c">!! unless `WDATA(1) &lt; 0.`, in which case the</span>
<span class="w">                                    </span><span class="c">!! dimension is assumed to be 1.</span>
<span class="w">    </span><span class="kt">real</span><span class="p">(</span><span class="n">wp</span><span class="p">),</span><span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">xmin</span><span class="p">(</span><span class="n">ndim</span><span class="p">)</span><span class="w"> </span><span class="c">!! A vector describing the lower extreme corner</span>
<span class="w">                                      </span><span class="c">!! of the node grid.  A set of evenly spaced</span>
<span class="w">                                      </span><span class="c">!! nodes is formed along each coordinate axis</span>
<span class="w">                                      </span><span class="c">!! and `XMIN(IDIM)` is the location of the first</span>
<span class="w">                                      </span><span class="c">!! node along the `IDIM` axis.  The dimension is</span>
<span class="w">                                      </span><span class="c">!! assumed to be `XMIN(NDIM)`.</span>
<span class="w">    </span><span class="kt">real</span><span class="p">(</span><span class="n">wp</span><span class="p">),</span><span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">xmax</span><span class="p">(</span><span class="n">ndim</span><span class="p">)</span><span class="w"> </span><span class="c">!! A vector describing the upper extreme corner</span>
<span class="w">                                      </span><span class="c">!! of the node grid.  A set of evenly spaced</span>
<span class="w">                                      </span><span class="c">!! nodes is formed along each coordinate axis</span>
<span class="w">                                      </span><span class="c">!! and `XMAX(IDIM)` is the location of the last</span>
<span class="w">                                      </span><span class="c">!! node along the `IDIM` axis.  The dimension is</span>
<span class="w">                                      </span><span class="c">!! assumed to be `XMAX(NDIM)`.</span>
<span class="w">    </span><span class="kt">real</span><span class="p">(</span><span class="n">wp</span><span class="p">),</span><span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">xtrap</span><span class="w"> </span><span class="c">!! A parameter to control extrapolation to data</span>
<span class="w">                                 </span><span class="c">!! sparse areas.  The region described by `XMIN`</span>
<span class="w">                                 </span><span class="c">!! and `XMAX` is divided into rectangles, the</span>
<span class="w">                                 </span><span class="c">!! number of which is determined by `NODES`, and</span>
<span class="w">                                 </span><span class="c">!! any rectangle containing a disproportionately</span>
<span class="w">                                 </span><span class="c">!! small number of data points is considered to</span>
<span class="w">                                 </span><span class="c">!! be data sparse (rectangle is used here to</span>
<span class="w">                                 </span><span class="c">!! mean `NDIM`-dimensional rectangle).  If `XTRAP`</span>
<span class="w">                                 </span><span class="c">!! is nonzero the least squares problem is</span>
<span class="w">                                 </span><span class="c">!! augmented with derivative constraints in the</span>
<span class="w">                                 </span><span class="c">!! data sparse areas to prevent the matrix from</span>
<span class="w">                                 </span><span class="c">!! becoming poorly conditioned.  `XTRAP` serves as</span>
<span class="w">                                 </span><span class="c">!! a weight for these constraints, and thus may</span>
<span class="w">                                 </span><span class="c">!! be used to control smoothness in data sparse</span>
<span class="w">                                 </span><span class="c">!! areas.  Experience indicates that unity is a</span>
<span class="w">                                 </span><span class="c">!! good first guess for this parameter.</span>
<span class="w">                                 </span><span class="c">!!</span>
<span class="w">                                 </span><span class="c">!!#### Note:</span>
<span class="w">                                 </span><span class="c">!! If `XTRAP` is zero, substantial</span>
<span class="w">                                 </span><span class="c">!! portions of the routine will be</span>
<span class="w">                                 </span><span class="c">!! skipped, but a singular matrix</span>
<span class="w">                                 </span><span class="c">!! can result if large portions of</span>
<span class="w">                                 </span><span class="c">!! the region are without data.</span>
<span class="w">    </span><span class="kt">integer</span><span class="p">,</span><span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">nodes</span><span class="p">(</span><span class="n">ndim</span><span class="p">)</span><span class="w"> </span><span class="c">!! A vector of integers describing the number of</span>
<span class="w">                                      </span><span class="c">!! nodes along each axis.  `NODES(IDIM)` is the</span>
<span class="w">                                      </span><span class="c">!! number of nodes (counting endpoints) along</span>
<span class="w">                                      </span><span class="c">!! the `IDIM` axis and determines the flexibility</span>
<span class="w">                                      </span><span class="c">!! of the spline in that coordinate direction.</span>
<span class="w">                                      </span><span class="c">!! `NODES(IDIM)` must be `&gt;= 4`, but may be as</span>
<span class="w">                                      </span><span class="c">!! large as the arrays `COEF` and `WORK` allow.</span>
<span class="w">                                      </span><span class="c">!! The dimension is assumed to be `NODES(NDIM)`.</span>
<span class="w">                                      </span><span class="c">!!</span>
<span class="w">                                      </span><span class="c">!!#### Note:</span>
<span class="w">                                      </span><span class="c">!! The node grid is completely defined by</span>
<span class="w">                                      </span><span class="c">!! the arguments `XMIN`, `XMAX` and `NODES`.</span>
<span class="w">                                      </span><span class="c">!! The spacing of this grid in the `IDIM`</span>
<span class="w">                                      </span><span class="c">!! coordinate direction is:</span>
<span class="w">                                      </span><span class="c">!!```fortran</span>
<span class="w">                                      </span><span class="c">!!   DX(IDIM) = (XMAX(IDIM)-XMIN(IDIM)) / (NODES(IDIM)-1).</span>
<span class="w">                                      </span><span class="c">!!```</span>
<span class="w">                                      </span><span class="c">!! A node in this grid may be indexed by</span>
<span class="w">                                      </span><span class="c">!! an `NDIM` vector of integers</span>
<span class="w">                                      </span><span class="c">!! `(IN(1),...,IN(NDIM))` where</span>
<span class="w">                                      </span><span class="c">!! `1 &lt;= IN(IDIM) &lt;= NODES(IDIM)`.</span>
<span class="w">                                      </span><span class="c">!! The location of such a node may be</span>
<span class="w">                                      </span><span class="c">!! represented by an `NDIM` vector</span>
<span class="w">                                      </span><span class="c">!! `(X(1),...,X(NDIM))` where</span>
<span class="w">                                      </span><span class="c">!! `X(IDIM) = XMIN(IDIM) + (IN(IDIM)-1) * DX(IDIM)`.</span>
<span class="w">    </span><span class="kt">real</span><span class="p">(</span><span class="n">wp</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">work</span><span class="p">(</span><span class="n">nwrk</span><span class="p">)</span><span class="w"> </span><span class="c">!! A workspace array for solving the least</span>
<span class="w">                           </span><span class="c">!! squares matrix generated by this routine.</span>
<span class="w">                           </span><span class="c">!! Its required size is a function of the total</span>
<span class="w">                           </span><span class="c">!! number of nodes in the node grid.  This</span>
<span class="w">                           </span><span class="c">!! total, `NCOL = NODES(1)*...*NODES(NDIM)`, is</span>
<span class="w">                           </span><span class="c">!! also the number of columns in the least</span>
<span class="w">                           </span><span class="c">!! squares matrix.  The length of the array `WORK`</span>
<span class="w">                           </span><span class="c">!! must equal or exceed `NCOL*(NCOL+1)`.</span>
<span class="w">    </span><span class="kt">real</span><span class="p">(</span><span class="n">wp</span><span class="p">),</span><span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">coef</span><span class="p">(</span><span class="n">ncf</span><span class="p">)</span><span class="w"> </span><span class="c">!! The array of coefficients computed by this</span>
<span class="w">                                      </span><span class="c">!! routine.  Each coefficient corresponds to a</span>
<span class="w">                                      </span><span class="c">!! particular basis function which in turn</span>
<span class="w">                                      </span><span class="c">!! corresponds to a node in the node grid.  This</span>
<span class="w">                                      </span><span class="c">!! correspondence between the node grid and the</span>
<span class="w">                                      </span><span class="c">!! array `COEF` is as if `COEF` were an</span>
<span class="w">                                      </span><span class="c">!! `NDIM`-dimensional Fortran array with</span>
<span class="w">                                      </span><span class="c">!! dimensions `NODES(1),...,NODES(NDIM)`, i.e., to</span>
<span class="w">                                      </span><span class="c">!! store the array linearly, the leftmost</span>
<span class="w">                                      </span><span class="c">!! indices are incremented most frequently.</span>
<span class="w">                                      </span><span class="c">!! Hence the length of the `COEF` array must equal</span>
<span class="w">                                      </span><span class="c">!! or exceed the total number of nodes, which is</span>
<span class="w">                                      </span><span class="c">!! `NODES(1)*...*NODES(NDIM)`.  The computed array</span>
<span class="w">                                      </span><span class="c">!! `COEF` may be used with function [[SPLFE]]</span>
<span class="w">                                      </span><span class="c">!! (or [[SPLDE]]) to evaluate the spline (or its</span>
<span class="w">                                      </span><span class="c">!! derivatives) at an arbitrary point in `NDIM`</span>
<span class="w">                                      </span><span class="c">!! space.  The dimension is assumed to be `COEF(NCF)`.</span>
<span class="w">    </span><span class="kt">integer</span><span class="p">,</span><span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">ierror</span><span class="w"> </span><span class="c">!! An error flag with the following meanings:</span>
<span class="w">                                  </span><span class="c">!!</span>
<span class="w">                                  </span><span class="c">!! * `  0`  No error.</span>
<span class="w">                                  </span><span class="c">!! * `101`  `NDIM` is &lt; 1.</span>
<span class="w">                                  </span><span class="c">!! * `102`  `NODES(IDIM)` is &lt; 4 for some `IDIM`.</span>
<span class="w">                                  </span><span class="c">!! * `103`  `XMIN(IDIM) = XMAX(IDIM)` for some `IDIM`.</span>
<span class="w">                                  </span><span class="c">!! * `104`  `NCF` (size of `COEF`) is `&lt; NODES(1)*...*NODES(NDIM)`.</span>
<span class="w">                                  </span><span class="c">!! * `105`  `NDATA` is `&lt; 1`.</span>
<span class="w">                                  </span><span class="c">!! * `106`  `NWRK` (size of `WORK`) is too small.</span>
<span class="w">                                  </span><span class="c">!! * `107`  [[suprls]] failure (usually insufficient</span>
<span class="w">                                  </span><span class="c">!!   data) -- ordinarily occurs only if</span>
<span class="w">                                  </span><span class="c">!!   `XTRAP` is zero or `WDATA` contains all</span>
<span class="w">                                  </span><span class="c">!!   zeros.</span>

<span class="w">    </span><span class="kt">real</span><span class="p">(</span><span class="n">wp</span><span class="p">),</span><span class="k">dimension</span><span class="p">(:),</span><span class="k">allocatable</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">x</span><span class="w"></span>
<span class="w">    </span><span class="kt">integer</span><span class="p">,</span><span class="k">dimension</span><span class="p">(:),</span><span class="k">allocatable</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">nderiv</span><span class="p">,</span><span class="n">in</span><span class="p">,</span><span class="n">inmx</span><span class="w"></span>
<span class="w">    </span><span class="kt">real</span><span class="p">(</span><span class="n">wp</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">xrng</span><span class="p">,</span><span class="n">swght</span><span class="p">,</span><span class="n">rowwt</span><span class="p">,</span><span class="n">rhs</span><span class="p">,</span><span class="n">basm</span><span class="p">,</span><span class="n">reserr</span><span class="p">,</span><span class="n">totlwt</span><span class="p">,&amp;</span><span class="w"></span>
<span class="w">                </span><span class="n">bump</span><span class="p">,</span><span class="n">wtprrc</span><span class="p">,</span><span class="n">expect</span><span class="p">,</span><span class="n">dcwght</span><span class="w"></span>
<span class="w">    </span><span class="kt">integer</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">ncol</span><span class="p">,</span><span class="nb">idim</span><span class="p">,</span><span class="n">nod</span><span class="p">,</span><span class="n">nwrk1</span><span class="p">,</span><span class="n">mdata</span><span class="p">,</span><span class="n">nwlft</span><span class="p">,</span><span class="n">irow</span><span class="p">,</span><span class="n">idata</span><span class="p">,&amp;</span><span class="w"></span>
<span class="w">               </span><span class="n">icol</span><span class="p">,</span><span class="n">it</span><span class="p">,</span><span class="n">lserr</span><span class="p">,</span><span class="n">iin</span><span class="p">,</span><span class="n">nrect</span><span class="p">,</span><span class="n">idimc</span><span class="p">,</span><span class="n">idm</span><span class="p">,</span><span class="n">jdm</span><span class="p">,</span><span class="n">inidim</span><span class="w"></span>
<span class="w">    </span><span class="kt">logical</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">boundary</span><span class="w"></span>

<span class="w">    </span><span class="kt">real</span><span class="p">(</span><span class="n">wp</span><span class="p">),</span><span class="k">parameter</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">spcrit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.75_wp</span><span class="w"></span>
<span class="w">        </span><span class="c">!! SPCRIT is used to determine data sparseness as follows -</span>
<span class="w">        </span><span class="c">!! the weights assigned to all data points are totaled into the</span>
<span class="w">        </span><span class="c">!! variable TOTLWT. (If no weights are entered, it is set to</span>
<span class="w">        </span><span class="c">!! NDATA.)  Each node of the node network is assigned a</span>
<span class="w">        </span><span class="c">!! rectangle (in which it is contained) and the weights of all</span>
<span class="w">        </span><span class="c">!! data points which fall in that rectangle are totaled.  If that</span>
<span class="w">        </span><span class="c">!! total is less than SPCRIT*EXPECT (EXPECT is defined below),</span>
<span class="w">        </span><span class="c">!! then the node is ascertained to be in a data sparse location.</span>
<span class="w">        </span><span class="c">!! EXPECT is that fraction of TOTLWT that would be expected by</span>
<span class="w">        </span><span class="c">!! comparing the area of the rectangle with the total area under</span>
<span class="w">        </span><span class="c">!! consideration.</span>

<span class="w">    </span><span class="c">! size the arrays:</span>
<span class="w">    </span><span class="k">call </span><span class="n">me</span><span class="p">%</span><span class="n">destroy</span><span class="p">(</span><span class="n">ndim</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="k">allocate</span><span class="p">(</span><span class="n">x</span><span class="p">(</span><span class="n">ndim</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="k">allocate</span><span class="p">(</span><span class="n">nderiv</span><span class="p">(</span><span class="n">ndim</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="k">allocate</span><span class="p">(</span><span class="n">in</span><span class="p">(</span><span class="n">ndim</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="k">allocate</span><span class="p">(</span><span class="n">inmx</span><span class="p">(</span><span class="n">ndim</span><span class="p">))</span><span class="w"></span>

<span class="w">    </span><span class="n">ierror</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">    </span><span class="n">me</span><span class="p">%</span><span class="n">mdim</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ndim</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">me</span><span class="p">%</span><span class="n">mdim</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="k">then</span>
<span class="k">        </span><span class="n">ierror</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">101</span><span class="w"></span>
<span class="w">        </span><span class="k">call </span><span class="n">cfaerr</span><span class="p">(</span><span class="n">ierror</span><span class="p">,</span><span class="w"> </span><span class="p">&amp;</span><span class="w"></span>
<span class="w">            </span><span class="s1">&#39; splcc or splcw - NDIM is less than 1&#39;</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span>
<span class="k">    end if</span>

<span class="k">    </span><span class="n">ncol</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">    </span><span class="k">do </span><span class="nb">idim</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="n">me</span><span class="p">%</span><span class="n">mdim</span><span class="w"></span>
<span class="w">        </span><span class="n">nod</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nodes</span><span class="p">(</span><span class="nb">idim</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">nod</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="k">then</span>
<span class="k">            </span><span class="n">ierror</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">102</span><span class="w"></span>
<span class="w">            </span><span class="k">call </span><span class="n">cfaerr</span><span class="p">(</span><span class="n">ierror</span><span class="p">,</span><span class="w"> </span><span class="p">&amp;</span><span class="w"></span>
<span class="w">                </span><span class="s1">&#39; splcc or splcw - NODES(IDIM) is less than 4 for some IDIM&#39;</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="k">return</span>
<span class="k">        end if</span><span class="w"></span>

<span class="w">        </span><span class="c">!  Number of columns in least squares matrix = number of coefficients =</span>
<span class="w">        </span><span class="c">!  product of nodes over all dimensions.</span>
<span class="w">        </span><span class="n">ncol</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ncol</span><span class="o">*</span><span class="n">nod</span><span class="w"></span>
<span class="w">        </span><span class="n">xrng</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xmax</span><span class="p">(</span><span class="nb">idim</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">xmin</span><span class="p">(</span><span class="nb">idim</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">xrng</span><span class="o">==</span><span class="mf">0.0_wp</span><span class="p">)</span><span class="w"> </span><span class="k">then</span>
<span class="k">            </span><span class="n">ierror</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">103</span><span class="w"></span>
<span class="w">            </span><span class="k">call </span><span class="n">cfaerr</span><span class="p">(</span><span class="n">ierror</span><span class="p">,</span><span class="w"> </span><span class="p">&amp;</span><span class="w"></span>
<span class="w">                </span><span class="s1">&#39; splcc or splcw - XMIN(IDIM) equals XMAX(IDIM) for some IDIM&#39;</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="k">return</span>
<span class="k">        end if</span><span class="w"></span>

<span class="w">        </span><span class="c">!  DX(IDIM) is the node spacing along the IDIM coordinate.</span>
<span class="w">        </span><span class="n">me</span><span class="p">%</span><span class="n">dx</span><span class="p">(</span><span class="nb">idim</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xrng</span><span class="o">/</span><span class="kt">real</span><span class="p">(</span><span class="n">nod</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">wp</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">me</span><span class="p">%</span><span class="n">dxin</span><span class="p">(</span><span class="nb">idim</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0_wp</span><span class="o">/</span><span class="n">me</span><span class="p">%</span><span class="n">dx</span><span class="p">(</span><span class="nb">idim</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">nderiv</span><span class="p">(</span><span class="nb">idim</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">    </span><span class="k">end do</span>
<span class="k">    if</span><span class="w"> </span><span class="p">(</span><span class="n">ncol</span><span class="o">&gt;</span><span class="n">ncf</span><span class="p">)</span><span class="w"> </span><span class="k">then</span>
<span class="k">        </span><span class="n">ierror</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">104</span><span class="w"></span>
<span class="w">        </span><span class="k">call </span><span class="n">cfaerr</span><span class="p">(</span><span class="n">ierror</span><span class="p">,</span><span class="w"> </span><span class="p">&amp;</span><span class="w"></span>
<span class="w">            </span><span class="s1">&#39; splcc or splcw - NCF (size of COEF) is too small&#39;</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span>
<span class="k">    end if</span>
<span class="k">    </span><span class="n">nwrk1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">    </span><span class="n">mdata</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ndata</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">mdata</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="k">then</span>
<span class="k">        </span><span class="n">ierror</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">105</span><span class="w"></span>
<span class="w">        </span><span class="k">call </span><span class="n">cfaerr</span><span class="p">(</span><span class="n">ierror</span><span class="p">,</span><span class="w"> </span><span class="p">&amp;</span><span class="w"></span>
<span class="w">            </span><span class="s1">&#39; splcc or splcw - Ndata Is less than 1&#39;</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span>
<span class="k">    end if</span><span class="w"></span>

<span class="w">    </span><span class="c">!  SWGHT is a local variable = XTRAP, and can be considered a smoothing</span>
<span class="w">    </span><span class="c">!  weight for data sparse areas.  If SWGHT == 0, no smoothing</span>
<span class="w">    </span><span class="c">!  computations are performed.</span>
<span class="w">    </span><span class="n">swght</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xtrap</span><span class="w"></span>

<span class="w">    </span><span class="c">!  Set aside workspace for counting data points.</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">swght</span><span class="o">/=</span><span class="mf">0.0_wp</span><span class="p">)</span><span class="w"> </span><span class="n">nwrk1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ncol</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>

<span class="w">    </span><span class="c">!  NWLFT is the length of the remaining workspace.</span>
<span class="w">    </span><span class="n">nwlft</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nwrk</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">nwrk1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">nwlft</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="k">then</span>
<span class="k">        </span><span class="n">ierror</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">106</span><span class="w"></span>
<span class="w">        </span><span class="k">call </span><span class="n">cfaerr</span><span class="p">(</span><span class="n">ierror</span><span class="p">,</span><span class="w"> </span><span class="p">&amp;</span><span class="w"></span>
<span class="w">            </span><span class="s1">&#39; splcc or splcw - NWRK (size of WORK) is too small&#39;</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span>
<span class="k">    end if</span>
<span class="k">    </span><span class="n">irow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>

<span class="w">    </span><span class="c">!  ROWWT is used to weight rows of the least squares matrix.</span>
<span class="w">    </span><span class="n">rowwt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0_wp</span><span class="w"></span>

<span class="w">    </span><span class="c">!  Loop through all data points, computing a row for each.</span>
<span class="w">    </span><span class="k">do </span><span class="n">idata</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="n">mdata</span><span class="w"></span>

<span class="w">        </span><span class="c">!  WDATA(1)&lt;0 means weights have not been entered.  In that case,</span>
<span class="w">        </span><span class="c">!  ROWWT is left equal to  1. for all points.  Otherwise ROWWT is</span>
<span class="w">        </span><span class="c">!  equal to WDATA(IDATA).</span>
<span class="w">        </span><span class="c">!</span>
<span class="w">        </span><span class="c">!  Every element of the row, as well as the corresponding right hand</span>
<span class="w">        </span><span class="c">!  side, is multiplied by ROWWT.</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">wdata</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">&gt;=</span><span class="mf">0.0_wp</span><span class="p">)</span><span class="w"> </span><span class="k">then</span>
<span class="k">            </span><span class="n">rowwt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">wdata</span><span class="p">(</span><span class="n">idata</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="c">!  Data points with 0 weight are ignored.</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rowwt</span><span class="o">==</span><span class="mf">0.0_wp</span><span class="p">)</span><span class="w"> </span><span class="k">cycle</span>
<span class="k">        end if</span>
<span class="k">        </span><span class="n">irow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">irow</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>

<span class="w">        </span><span class="c">!  One row of the least squares matrix corresponds to each data</span>
<span class="w">        </span><span class="c">!  point.  The right hand for that row will correspond to the</span>
<span class="w">        </span><span class="c">!  function value YDATA at that point.</span>
<span class="w">        </span><span class="n">rhs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rowwt</span><span class="o">*</span><span class="n">ydata</span><span class="p">(</span><span class="n">idata</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="k">do </span><span class="nb">idim</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="n">me</span><span class="p">%</span><span class="n">mdim</span><span class="w"></span>
<span class="w">            </span><span class="n">x</span><span class="p">(</span><span class="nb">idim</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xdata</span><span class="p">(</span><span class="nb">idim</span><span class="p">,</span><span class="n">idata</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="k">end do</span><span class="w"></span>

<span class="w">        </span><span class="c">!  The COEF array serves as a row of least squares matrix.</span>
<span class="w">        </span><span class="c">!  Its value is zero except for columns corresponding to functions</span>
<span class="w">        </span><span class="c">!  which are nonzero at X.</span>
<span class="w">        </span><span class="k">do </span><span class="n">icol</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="n">ncol</span><span class="w"></span>
<span class="w">            </span><span class="n">coef</span><span class="p">(</span><span class="n">icol</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0_wp</span><span class="w"></span>
<span class="w">        </span><span class="k">end do</span><span class="w"></span>

<span class="w">        </span><span class="c">!  Compute the indices of basis functions which are nonzero at X.</span>
<span class="w">        </span><span class="c">!  IBMN is in the range 0 to nodes-2 and IBMX is in range 1</span>
<span class="w">        </span><span class="c">!  to NODES-1.</span>
<span class="w">        </span><span class="k">do </span><span class="nb">idim</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="n">me</span><span class="p">%</span><span class="n">mdim</span><span class="w"></span>
<span class="w">            </span><span class="n">nod</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nodes</span><span class="p">(</span><span class="nb">idim</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">me</span><span class="p">%</span><span class="n">dxin</span><span class="p">(</span><span class="nb">idim</span><span class="p">)</span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">(</span><span class="nb">idim</span><span class="p">)</span><span class="o">-</span><span class="n">xmin</span><span class="p">(</span><span class="nb">idim</span><span class="p">))</span><span class="w"></span>
<span class="w">            </span><span class="n">me</span><span class="p">%</span><span class="n">ibmn</span><span class="p">(</span><span class="nb">idim</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">min</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">it</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="n">nod</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="n">me</span><span class="p">%</span><span class="n">ib</span><span class="p">(</span><span class="nb">idim</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">me</span><span class="p">%</span><span class="n">ibmn</span><span class="p">(</span><span class="nb">idim</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="n">me</span><span class="p">%</span><span class="n">ibmx</span><span class="p">(</span><span class="nb">idim</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">max</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">it</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="n">nod</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="k">end do</span>

<span class="k">        </span><span class="n">basis_index</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">            </span><span class="c">!  Begining of basis index loop - traverse all indices corresponding</span>
<span class="w">            </span><span class="c">!  to basis functions which are nonzero at X.  The indices are in</span>
<span class="w">            </span><span class="c">!  IB and are passed through common to BASCMP.</span>
<span class="w">            </span><span class="k">call </span><span class="n">me</span><span class="p">%</span><span class="n">bascmp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">nderiv</span><span class="p">,</span><span class="n">xmin</span><span class="p">,</span><span class="n">nodes</span><span class="p">,</span><span class="n">icol</span><span class="p">,</span><span class="n">basm</span><span class="p">)</span><span class="w"></span>

<span class="w">            </span><span class="c">!  BASCMP computes ICOL and BASM where BASM is the value at X of</span>
<span class="w">            </span><span class="c">!  the N-dimensional basis function corresponding to column ICOL.</span>
<span class="w">            </span><span class="n">coef</span><span class="p">(</span><span class="n">icol</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rowwt</span><span class="o">*</span><span class="n">basm</span><span class="w"></span>

<span class="w">            </span><span class="c">!  Increment the basis indices.</span>
<span class="w">            </span><span class="k">do </span><span class="nb">idim</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="n">me</span><span class="p">%</span><span class="n">mdim</span><span class="w"></span>
<span class="w">                </span><span class="n">me</span><span class="p">%</span><span class="n">ib</span><span class="p">(</span><span class="nb">idim</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">me</span><span class="p">%</span><span class="n">ib</span><span class="p">(</span><span class="nb">idim</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">me</span><span class="p">%</span><span class="n">ib</span><span class="p">(</span><span class="nb">idim</span><span class="p">)</span><span class="o">&lt;=</span><span class="n">me</span><span class="p">%</span><span class="n">ibmx</span><span class="p">(</span><span class="nb">idim</span><span class="p">))</span><span class="w"> </span><span class="k">cycle </span><span class="n">basis_index</span><span class="w"></span>
<span class="w">                </span><span class="n">me</span><span class="p">%</span><span class="n">ib</span><span class="p">(</span><span class="nb">idim</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">me</span><span class="p">%</span><span class="n">ibmn</span><span class="p">(</span><span class="nb">idim</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="k">end do</span>
<span class="k">            exit </span><span class="n">basis_index</span><span class="w"> </span><span class="c">!  End of basis index loop.</span>
<span class="w">        </span><span class="k">end do </span><span class="n">basis_index</span><span class="w"></span>

<span class="w">        </span><span class="c">!  Send a row of the least squares matrix to the reduction routine.</span>
<span class="w">        </span><span class="k">call </span><span class="n">me</span><span class="p">%</span><span class="n">suprls</span><span class="p">(</span><span class="n">irow</span><span class="p">,</span><span class="n">coef</span><span class="p">,</span><span class="n">ncol</span><span class="p">,</span><span class="n">rhs</span><span class="p">,</span><span class="n">work</span><span class="p">(</span><span class="n">nwrk1</span><span class="p">),</span><span class="n">nwlft</span><span class="p">,</span><span class="n">coef</span><span class="p">,</span><span class="n">reserr</span><span class="p">,</span><span class="n">lserr</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">lserr</span><span class="o">/=</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="k">then</span>
<span class="k">            </span><span class="n">ierror</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">107</span><span class="w"></span>
<span class="w">            </span><span class="k">call </span><span class="n">cfaerr</span><span class="p">(</span><span class="n">ierror</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39; splcc or splcw - suprls failure &#39;</span><span class="o">//</span><span class="p">&amp;</span><span class="w"></span>
<span class="w">                                </span><span class="s1">&#39;(this usually indicates insufficient input data)&#39;</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="k">end if</span>
<span class="k">    end do</span><span class="w"></span>

<span class="w">    </span><span class="c">!  Row computations for all data points are now complete.</span>
<span class="w">    </span><span class="c">!</span>
<span class="w">    </span><span class="c">!  If SWGHT==0, the least squares matrix is complete and no</span>
<span class="w">    </span><span class="c">!  smoothing rows are computed.</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">swght</span><span class="o">/=</span><span class="mf">0.0_wp</span><span class="p">)</span><span class="w"> </span><span class="k">then</span><span class="w"></span>

<span class="w">        </span><span class="c">!  Initialize smoothing computations for data sparse areas.</span>
<span class="w">        </span><span class="c">!  Derivative constraints will always have zero right hand side.</span>
<span class="w">        </span><span class="n">rhs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0_wp</span><span class="w"></span>
<span class="w">        </span><span class="n">nrect</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>

<span class="w">        </span><span class="c">!  Initialize the node indices and compute number of rectangles</span>
<span class="w">        </span><span class="c">!  formed by the node network.</span>
<span class="w">        </span><span class="k">do </span><span class="nb">idim</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="n">me</span><span class="p">%</span><span class="n">mdim</span><span class="w"></span>
<span class="w">            </span><span class="n">in</span><span class="p">(</span><span class="nb">idim</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">            </span><span class="n">inmx</span><span class="p">(</span><span class="nb">idim</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nodes</span><span class="p">(</span><span class="nb">idim</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">            </span><span class="n">nrect</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nrect</span><span class="o">*</span><span class="n">inmx</span><span class="p">(</span><span class="nb">idim</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="k">end do</span><span class="w"></span>

<span class="w">        </span><span class="c">!  Every node is assigned an element of the workspace (set aside</span>
<span class="w">        </span><span class="c">!  previously) in which data points are counted.</span>
<span class="w">        </span><span class="k">do </span><span class="n">iin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="n">ncol</span><span class="w"></span>
<span class="w">            </span><span class="n">work</span><span class="p">(</span><span class="n">iin</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0_wp</span><span class="w"></span>
<span class="w">        </span><span class="k">end do</span><span class="w"></span>

<span class="w">        </span><span class="c">!  Assign each data point to a node, total the assignments for</span>
<span class="w">        </span><span class="c">!  each node, and save in the workspace.</span>
<span class="w">        </span><span class="n">totlwt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0_wp</span><span class="w"></span>
<span class="w">        </span><span class="k">do </span><span class="n">idata</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="n">mdata</span><span class="w"></span>

<span class="w">            </span><span class="c">! BUMP is the weight associated with the data point.</span>
<span class="w">            </span><span class="n">bump</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0_wp</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">wdata</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">&gt;=</span><span class="mf">0.0_wp</span><span class="p">)</span><span class="w"> </span><span class="n">bump</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">wdata</span><span class="p">(</span><span class="n">idata</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">bump</span><span class="o">==</span><span class="mf">0.0_wp</span><span class="p">)</span><span class="w"> </span><span class="k">cycle</span><span class="w"></span>

<span class="w">            </span><span class="c">! Find the nearest node.</span>
<span class="w">            </span><span class="n">iin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">            </span><span class="k">do </span><span class="n">idimc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="n">me</span><span class="p">%</span><span class="n">mdim</span><span class="w"></span>
<span class="w">                </span><span class="nb">idim</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">me</span><span class="p">%</span><span class="n">mdim</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">idimc</span><span class="w"></span>
<span class="w">                </span><span class="n">inidim</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">int</span><span class="p">(</span><span class="n">me</span><span class="p">%</span><span class="n">dxin</span><span class="p">(</span><span class="nb">idim</span><span class="p">)</span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">xdata</span><span class="p">(</span><span class="nb">idim</span><span class="p">,</span><span class="n">idata</span><span class="p">)</span><span class="o">-</span><span class="n">xmin</span><span class="p">(</span><span class="nb">idim</span><span class="p">))</span><span class="o">+</span><span class="mf">0.5_wp</span><span class="p">)</span><span class="w"></span>
<span class="w">                </span><span class="c">! Points not in range (+ or - 1/2 node spacing) are not counted.</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">inidim</span><span class="o">&lt;</span><span class="mi">0</span><span class="w"> </span><span class="p">.</span><span class="nb">or</span><span class="p">.</span><span class="w"> </span><span class="n">inidim</span><span class="o">&gt;</span><span class="n">inmx</span><span class="p">(</span><span class="nb">idim</span><span class="p">))</span><span class="w"> </span><span class="k">cycle</span><span class="w"></span>
<span class="w">                </span><span class="c">! Compute linear address of node in workspace by Horner&#39;s method.</span>
<span class="w">                </span><span class="n">iin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">inmx</span><span class="p">(</span><span class="nb">idim</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">iin</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">inidim</span><span class="w"></span>
<span class="w">            </span><span class="k">end do</span><span class="w"></span>

<span class="w">            </span><span class="c">! Bump counter for that node.</span>
<span class="w">            </span><span class="n">work</span><span class="p">(</span><span class="n">iin</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">work</span><span class="p">(</span><span class="n">iin</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">bump</span><span class="w"></span>
<span class="w">            </span><span class="n">totlwt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">totlwt</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">bump</span><span class="w"></span>
<span class="w">        </span><span class="k">end do</span><span class="w"></span>

<span class="w">        </span><span class="c">! Compute the expected weight per rectangle.</span>
<span class="w">        </span><span class="n">wtprrc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">totlwt</span><span class="o">/</span><span class="kt">real</span><span class="p">(</span><span class="n">nrect</span><span class="p">,</span><span class="n">wp</span><span class="p">)</span><span class="w"></span>

<span class="w">        </span><span class="c">!  IN contains indices of the node (previously initialized).</span>
<span class="w">        </span><span class="c">!  IIN will be the linear address of the node in the workspace.</span>
<span class="w">        </span><span class="n">iin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>

<span class="w">        </span><span class="c">!  Loop through all nodes, computing derivative constraint rows</span>
<span class="w">        </span><span class="c">!  for those in data sparse locations.</span>
<span class="w">        </span><span class="c">!</span>
<span class="w">        </span><span class="c">!  Begining of node index loop - traverse all node indices.</span>
<span class="w">        </span><span class="c">!  The indices are in IN.</span>
<span class="w">        </span><span class="n">node_index</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="k">do</span>
<span class="k">            </span><span class="n">iin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iin</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">            </span><span class="n">expect</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">wtprrc</span><span class="w"></span>

<span class="w">            </span><span class="c">!  Rectangles at edge of network are smaller and hence less weight</span>
<span class="w">            </span><span class="c">!  should be expected.</span>
<span class="w">            </span><span class="k">do </span><span class="nb">idim</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="n">me</span><span class="p">%</span><span class="n">mdim</span><span class="w"></span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">in</span><span class="p">(</span><span class="nb">idim</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="w"> </span><span class="p">.</span><span class="nb">or</span><span class="p">.</span><span class="w"> </span><span class="n">in</span><span class="p">(</span><span class="nb">idim</span><span class="p">)</span><span class="o">==</span><span class="n">inmx</span><span class="p">(</span><span class="nb">idim</span><span class="p">))</span><span class="w"> </span><span class="n">expect</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.5_wp</span><span class="o">*</span><span class="n">expect</span><span class="w"></span>
<span class="w">            </span><span class="k">end do</span><span class="w"></span>

<span class="w">            </span><span class="c">!  The expected weight minus the actual weight serves to define</span>
<span class="w">            </span><span class="c">!  data sparseness and is also used to weight the derivative</span>
<span class="w">            </span><span class="c">!  constraint rows.</span>
<span class="w">            </span><span class="c">!</span>
<span class="w">            </span><span class="c">!  There is no constraint if not data sparse.</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">work</span><span class="p">(</span><span class="n">iin</span><span class="p">)</span><span class="o">&lt;</span><span class="n">spcrit</span><span class="o">*</span><span class="n">expect</span><span class="p">)</span><span class="w"> </span><span class="k">then</span>

<span class="k">                </span><span class="n">dcwght</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">expect</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">work</span><span class="p">(</span><span class="n">iin</span><span class="p">)</span><span class="w"></span>
<span class="w">                </span><span class="k">do </span><span class="nb">idim</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="n">me</span><span class="p">%</span><span class="n">mdim</span><span class="w"></span>
<span class="w">                    </span><span class="n">inidim</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="p">(</span><span class="nb">idim</span><span class="p">)</span><span class="w"></span>

<span class="w">                    </span><span class="c">!  Compute the location of the node.</span>
<span class="w">                    </span><span class="n">x</span><span class="p">(</span><span class="nb">idim</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xmin</span><span class="p">(</span><span class="nb">idim</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="kt">real</span><span class="p">(</span><span class="n">inidim</span><span class="p">,</span><span class="n">wp</span><span class="p">)</span><span class="o">*</span><span class="n">me</span><span class="p">%</span><span class="n">dx</span><span class="p">(</span><span class="nb">idim</span><span class="p">)</span><span class="w"></span>

<span class="w">                    </span><span class="c">!  Compute the indices of the basis functions which are non-zero</span>
<span class="w">                    </span><span class="c">!  at the node.</span>
<span class="w">                    </span><span class="n">me</span><span class="p">%</span><span class="n">ibmn</span><span class="p">(</span><span class="nb">idim</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inidim</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">                    </span><span class="n">me</span><span class="p">%</span><span class="n">ibmx</span><span class="p">(</span><span class="nb">idim</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inidim</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>

<span class="w">                    </span><span class="c">!  Distinguish the boundaries.</span>
<span class="w">                    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">inidim</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">me</span><span class="p">%</span><span class="n">ibmn</span><span class="p">(</span><span class="nb">idim</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">                    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">inidim</span><span class="o">==</span><span class="n">inmx</span><span class="p">(</span><span class="nb">idim</span><span class="p">))</span><span class="w"> </span><span class="n">me</span><span class="p">%</span><span class="n">ibmx</span><span class="p">(</span><span class="nb">idim</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inmx</span><span class="p">(</span><span class="nb">idim</span><span class="p">)</span><span class="w"></span>

<span class="w">                    </span><span class="c">!  Initialize the basis indices.</span>
<span class="w">                    </span><span class="n">me</span><span class="p">%</span><span class="n">ib</span><span class="p">(</span><span class="nb">idim</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">me</span><span class="p">%</span><span class="n">ibmn</span><span class="p">(</span><span class="nb">idim</span><span class="p">)</span><span class="w"></span>
<span class="w">                </span><span class="k">end do</span><span class="w"></span>

<span class="w">                </span><span class="c">!  Multiply by the extrapolation parameter (this acts as a</span>
<span class="w">                </span><span class="c">!  smoothing weight).</span>
<span class="w">                </span><span class="n">dcwght</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">swght</span><span class="o">*</span><span class="n">dcwght</span><span class="w"></span>

<span class="w">                </span><span class="c">!  The COEF array serves as a row of the least squares matrix.</span>
<span class="w">                </span><span class="c">!  Its value is zero except for columns corresponding to functions</span>
<span class="w">                </span><span class="c">!  which are non-zero at the node.</span>
<span class="w">                </span><span class="k">do </span><span class="n">icol</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="n">ncol</span><span class="w"></span>
<span class="w">                    </span><span class="n">coef</span><span class="p">(</span><span class="n">icol</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0_wp</span><span class="w"></span>
<span class="w">                </span><span class="k">end do</span><span class="w"></span>

<span class="w">                </span><span class="c">!  The 2nd derivative of a function of MDIM variables may be thought</span>
<span class="w">                </span><span class="c">!  of as a symmetric MDIM x MDIM matrix of 2nd order partial</span>
<span class="w">                </span><span class="c">!  derivatives.  Traverse the upper triangle of this matrix and,</span>
<span class="w">                </span><span class="c">!  for each element, compute a row of the least squares matrix.</span>

<span class="w">                </span><span class="k">do </span><span class="n">idm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="n">me</span><span class="p">%</span><span class="n">mdim</span><span class="w"></span>
<span class="w">                    </span><span class="k">do </span><span class="n">jdm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">idm</span><span class="p">,</span><span class="n">me</span><span class="p">%</span><span class="n">mdim</span><span class="w"></span>
<span class="w">                        </span><span class="k">do </span><span class="nb">idim</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="n">me</span><span class="p">%</span><span class="n">mdim</span><span class="w"></span>
<span class="w">                            </span><span class="n">nderiv</span><span class="p">(</span><span class="nb">idim</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">                        </span><span class="k">end do</span>

<span class="k">                        </span><span class="n">boundary</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">.</span><span class="n">true</span><span class="p">.</span><span class="w"></span>
<span class="w">                        </span><span class="c">!  Off-diagonal elements appear twice by symmetry, so the corresponding</span>
<span class="w">                        </span><span class="c">!  row is weighted by a factor of 2.</span>
<span class="w">                        </span><span class="n">rowwt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.0_wp</span><span class="o">*</span><span class="n">dcwght</span><span class="w"></span>
<span class="w">                        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">jdm</span><span class="o">==</span><span class="n">idm</span><span class="p">)</span><span class="w"> </span><span class="k">then</span><span class="w"></span>
<span class="w">                            </span><span class="c">!  Diagonal.</span>
<span class="w">                            </span><span class="n">rowwt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dcwght</span><span class="w"></span>
<span class="w">                            </span><span class="n">nderiv</span><span class="p">(</span><span class="n">jdm</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="w"></span>
<span class="w">                            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">in</span><span class="p">(</span><span class="n">idm</span><span class="p">)</span><span class="o">/=</span><span class="mi">0</span><span class="w"> </span><span class="p">.</span><span class="nb">and</span><span class="p">.</span><span class="w"> </span><span class="n">in</span><span class="p">(</span><span class="n">idm</span><span class="p">)</span><span class="o">/=</span><span class="n">inmx</span><span class="p">(</span><span class="n">idm</span><span class="p">))</span><span class="w"> </span><span class="k">then</span>
<span class="k">                                </span><span class="n">boundary</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">.</span><span class="n">false</span><span class="p">.</span><span class="w"></span>
<span class="w">                            </span><span class="k">end if</span>
<span class="k">                        end if</span>
<span class="k">                        if</span><span class="w"> </span><span class="p">(</span><span class="n">boundary</span><span class="p">)</span><span class="w"> </span><span class="k">then</span><span class="w"></span>
<span class="w">                            </span><span class="c">!  Node is at boundary.</span>
<span class="w">                            </span><span class="c">!</span>
<span class="w">                            </span><span class="c">!  Normal 2nd derivative constraint at boundary is not appropriate for</span>
<span class="w">                            </span><span class="c">!  natural splines (2nd derivative 0 by definition).  Substitute</span>
<span class="w">                            </span><span class="c">!  a 1st derivative constraint.</span>
<span class="w">                            </span><span class="n">nderiv</span><span class="p">(</span><span class="n">idm</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">                            </span><span class="n">nderiv</span><span class="p">(</span><span class="n">jdm</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">                        </span><span class="k">end if</span>
<span class="k">                        </span><span class="n">irow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">irow</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>

<span class="w">                        </span><span class="n">basis</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="k">do</span><span class="w"></span>
<span class="w">                            </span><span class="c">!  Begining of basis index loop - traverse all indices corresponding</span>
<span class="w">                            </span><span class="c">!  to basis functions which are non-zero at X.</span>
<span class="w">                            </span><span class="c">!  The indices are in IB and are passed through common to BASCMP.</span>
<span class="w">                            </span><span class="k">call </span><span class="n">me</span><span class="p">%</span><span class="n">bascmp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">nderiv</span><span class="p">,</span><span class="n">xmin</span><span class="p">,</span><span class="n">nodes</span><span class="p">,</span><span class="n">icol</span><span class="p">,</span><span class="n">basm</span><span class="p">)</span><span class="w"></span>

<span class="w">                            </span><span class="c">!  BASCMP computes ICOL and BASM where BASM is the value at X of the</span>
<span class="w">                            </span><span class="c">!  N-dimensional basis function corresponding to column ICOL.</span>
<span class="w">                            </span><span class="n">coef</span><span class="p">(</span><span class="n">icol</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rowwt</span><span class="o">*</span><span class="n">basm</span><span class="w"></span>

<span class="w">                            </span><span class="c">!  Increment the basis indices.</span>
<span class="w">                            </span><span class="k">do </span><span class="nb">idim</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="n">me</span><span class="p">%</span><span class="n">mdim</span><span class="w"></span>
<span class="w">                                </span><span class="n">me</span><span class="p">%</span><span class="n">ib</span><span class="p">(</span><span class="nb">idim</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">me</span><span class="p">%</span><span class="n">ib</span><span class="p">(</span><span class="nb">idim</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">                                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">me</span><span class="p">%</span><span class="n">ib</span><span class="p">(</span><span class="nb">idim</span><span class="p">)</span><span class="o">&lt;=</span><span class="n">me</span><span class="p">%</span><span class="n">ibmx</span><span class="p">(</span><span class="nb">idim</span><span class="p">))</span><span class="w"> </span><span class="k">cycle </span><span class="n">basis</span><span class="w"></span>
<span class="w">                                </span><span class="n">me</span><span class="p">%</span><span class="n">ib</span><span class="p">(</span><span class="nb">idim</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">me</span><span class="p">%</span><span class="n">ibmn</span><span class="p">(</span><span class="nb">idim</span><span class="p">)</span><span class="w"></span>
<span class="w">                            </span><span class="k">end do</span><span class="w"></span>

<span class="w">                            </span><span class="c">!  End of basis index loop.</span>
<span class="w">                            </span><span class="k">exit </span><span class="n">basis</span><span class="w"></span>
<span class="w">                        </span><span class="k">end do </span><span class="n">basis</span><span class="w"></span>

<span class="w">                        </span><span class="c">!  Send row of least squares matrix to reduction routine.</span>
<span class="w">                        </span><span class="k">call </span><span class="n">me</span><span class="p">%</span><span class="n">suprls</span><span class="p">(</span><span class="n">irow</span><span class="p">,</span><span class="n">coef</span><span class="p">,</span><span class="n">ncol</span><span class="p">,</span><span class="n">rhs</span><span class="p">,</span><span class="n">work</span><span class="p">(</span><span class="n">nwrk1</span><span class="p">),</span><span class="n">nwlft</span><span class="p">,</span><span class="n">coef</span><span class="p">,</span><span class="n">reserr</span><span class="p">,</span><span class="n">lserr</span><span class="p">)</span><span class="w"></span>
<span class="w">                        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">lserr</span><span class="o">/=</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="k">then</span>
<span class="k">                            </span><span class="n">ierror</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">107</span><span class="w"></span>
<span class="w">                            </span><span class="k">call </span><span class="n">cfaerr</span><span class="p">(</span><span class="n">ierror</span><span class="p">,</span><span class="w"> </span><span class="p">&amp;</span><span class="w"></span>
<span class="w">                                </span><span class="s1">&#39; splcc or splcw - suprls failure &#39;</span><span class="o">//</span><span class="p">&amp;</span><span class="w"></span>
<span class="w">                                </span><span class="s1">&#39;(this usually indicates insufficient input data)&#39;</span><span class="p">)</span><span class="w"></span>
<span class="w">                        </span><span class="k">end if</span>
<span class="k">                    end do</span>
<span class="k">                end do</span>

<span class="k">            end if</span><span class="w"></span>

<span class="w">            </span><span class="c">!  Increment node indices.</span>
<span class="w">            </span><span class="k">do </span><span class="nb">idim</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="n">me</span><span class="p">%</span><span class="n">mdim</span><span class="w"></span>
<span class="w">                </span><span class="n">in</span><span class="p">(</span><span class="nb">idim</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="p">(</span><span class="nb">idim</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">in</span><span class="p">(</span><span class="nb">idim</span><span class="p">)</span><span class="o">&lt;=</span><span class="n">inmx</span><span class="p">(</span><span class="nb">idim</span><span class="p">))</span><span class="w"> </span><span class="k">cycle </span><span class="n">node_index</span><span class="w"></span>
<span class="w">                </span><span class="n">in</span><span class="p">(</span><span class="nb">idim</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">            </span><span class="k">end do</span>

<span class="k">            exit </span><span class="n">node_index</span><span class="w"> </span><span class="c">!  End of node index loop.</span>

<span class="w">        </span><span class="k">end do </span><span class="n">node_index</span><span class="w"></span>

<span class="w">    </span><span class="k">end if</span><span class="w"></span>

<span class="w">    </span><span class="c">!  Call for least squares solution in COEF array.</span>
<span class="w">    </span><span class="n">irow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>
<span class="w">    </span><span class="k">call </span><span class="n">me</span><span class="p">%</span><span class="n">suprls</span><span class="p">(</span><span class="n">irow</span><span class="p">,</span><span class="n">coef</span><span class="p">,</span><span class="n">ncol</span><span class="p">,</span><span class="n">rhs</span><span class="p">,</span><span class="n">work</span><span class="p">(</span><span class="n">nwrk1</span><span class="p">),</span><span class="n">nwlft</span><span class="p">,</span><span class="n">coef</span><span class="p">,</span><span class="n">reserr</span><span class="p">,</span><span class="n">lserr</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">lserr</span><span class="o">/=</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="k">then</span>
<span class="k">        </span><span class="n">ierror</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">107</span><span class="w"></span>
<span class="w">        </span><span class="k">call </span><span class="n">cfaerr</span><span class="p">(</span><span class="n">ierror</span><span class="p">,</span><span class="w"> </span><span class="p">&amp;</span><span class="w"></span>
<span class="w">            </span><span class="s1">&#39; splcc or splcw - suprls failure &#39;</span><span class="o">//</span><span class="p">&amp;</span><span class="w"></span>
<span class="w">            </span><span class="s1">&#39;(this usually indicates insufficient input data)&#39;</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="k">end if</span>

<span class="k">end subroutine </span><span class="n">splcw</span><span class="w"></span>
</pre></div>

    </section>
    <br>
    
    </div>
  </div>

    <hr>    
    </div> <!-- /container -->
    <footer>
      <div class="container">
      <div class="row">
        <div class="col-xs-6 col-md-6"><p>splpak was developed by Jacob Williams<br>&copy; 2023 
</p>
        </div>
        <div class="col-xs-6 col-md-6">
          <p class="text-right">
            Documentation generated by 
            <a href="https://github.com/Fortran-FOSS-Programmers/ford">FORD</a>
          </p>
        </div>
      </div>
      <br>
      </div> <!-- /container -->    
    </footer>

    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
<!--
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
-->
    <script src="../js/bootstrap.min.js"></script>
    <!-- IE10 viewport hack for Surface/desktop Windows 8 bug -->
    <script src="../js/ie10-viewport-bug-workaround.js"></script>

    <!-- MathJax JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },
        jax: ['input/TeX','input/MathML','output/HTML-CSS'],
        extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']
      });
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script src="../tipuesearch/tipuesearch_content.js"></script>
    <script src="../tipuesearch/tipuesearch_set.js"></script>
    <script src="../tipuesearch/tipuesearch.js"></script>
    
  </body>
</html>